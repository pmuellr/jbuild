// Generated by CoffeeScript 1.6.3
(function() {
  var HelpTasks, PROGRAM, Tasks, alignLeft, coffee, fs, getTaskRunner, help, installNodeModuleScripts, invokeNodeModuleScript, main, path, pkg, watch, _,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require("fs");

  path = require("path");

  _ = require("underscore");

  coffee = require("coffee-script");

  require("shelljs/global");

  pkg = require("../package.json");

  watch = require("./watch");

  global.watch = watch.watch;

  global.watchFiles = watch.watchFiles;

  global.server = require("./server");

  PROGRAM = path.basename(__filename).split(".")[0];

  Tasks = null;

  HelpTasks = ["help", "?", "-?", "-h", "--h", "--help"];

  exports.execMain = function() {
    exec("node " + __filename + " " + ((process.argv.slice(2)).join(' ')));
    return process.exit(0);
  };

  exports.main = main = function() {
    var args, code, err, iFile, jmod, name, task, taskNames, taskObj;
    task = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (!test("-f", "jbuild.js") && !test("-f", "jbuild.coffee")) {
      if (__indexOf.call(HelpTasks, task) >= 0) {
        help();
      } else {
        logError("error: jbuild.js not found in current dir; use `jbuild help` for help");
      }
    }
    if (test("-f", "jbuild.coffee")) {
      code = cat("jbuild.coffee");
      try {
        coffee.compile(code, {
          compile: true,
          output: "jbuild.coffee.js"
        });
      } catch (_error) {
        err = _error;
        iFile = "jbuild.coffee";
        if (err.location.first_line) {
          iFile = "" + iFile + ":" + err.location.first_line;
          if (err.location.first_column) {
            iFile = "" + iFile + ":" + err.location.first_column;
          }
        }
        logError("error: syntax error in " + iFile + ": " + err);
      } finally {
        if (test("-f", "jbuild.coffee.js")) {
          rm("jbuild.coffee.js");
        }
      }
    }
    installNodeModuleScripts();
    try {
      jmod = require("" + (path.join(process.cwd(), 'jbuild')));
    } catch (_error) {
      err = _error;
      logError(err, "error: unable to load module ./jbuild: " + err);
    }
    Tasks = {};
    for (name in jmod) {
      taskObj = jmod[name];
      if (!_.isFunction(taskObj.run)) {
        logError("error: the run property of task " + name + " is not a function");
      }
      taskObj.name = name;
      if (taskObj.doc == null) {
        taskObj.doc = "???";
      }
      Tasks[name] = taskObj;
    }
    taskNames = _.keys(Tasks);
    if ((task == null) && taskNames.length === 1) {
      task = Tasks[taskNames[0]].name;
    }
    if ((task == null) || __indexOf.call(HelpTasks, task) >= 0) {
      help();
    }
    if (Tasks[task] == null) {
      logError("error: unknown task '" + task + "'; use `jbuild help` for help");
    }
    try {
      Tasks[task].run.apply(null, args);
    } catch (_error) {
      err = _error;
      logError(err, "running task " + task);
    }
  };

  global.defineTasks = function(exports_, tasksSpec) {
    var doc, name, run, tasks;
    tasks = {};
    for (name in tasksSpec) {
      doc = tasksSpec[name];
      run = getTaskRunner(tasks, name);
      exports_[name] = {
        doc: doc,
        run: run
      };
    }
    return tasks;
  };

  getTaskRunner = function(tasks, name) {
    return function() {
      var args, run;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      run = tasks[name];
      if (run == null) {
        logError("task run function for `" + name + "` not defined in tasks object");
      }
      return run.apply(null, args);
    };
  };

  global.pexec = function(command, options, callback) {
    if (_.isFunction(options && (callback == null))) {
      callback = options;
      options = {};
    }
    if (options == null) {
      options = {};
    }
    command = "node " + (path.join('node_modules', '.bin', command));
    if (_.isFunction(callback)) {
      return exec(command, options, callback);
    } else {
      return exec(command, options);
    }
  };

  global.log = function(message) {
    if ((message == null) || message === "") {
      console.log("");
    } else {
      console.log("" + PROGRAM + ": " + message);
    }
  };

  global.logError = function(err, message) {
    if ((err != null) && (message == null)) {
      message = err;
      err = null;
    }
    log(message);
    if (err && err.stack) {
      console.log("stack:");
      console.log(err.stack);
    }
    process.exit(1);
  };

  installNodeModuleScripts = function() {
    var nodeModulesBin, script, scripts, _i, _len, _results;
    nodeModulesBin = path.join("node_modules", ".bin");
    if (!test("-d", nodeModulesBin)) {
      return;
    }
    scripts = ls(nodeModulesBin);
    _results = [];
    for (_i = 0, _len = scripts.length; _i < _len; _i++) {
      script = scripts[_i];
      _results.push(global[script] = invokeNodeModuleScript(nodeModulesBin, script));
    }
    return _results;
  };

  invokeNodeModuleScript = function(scriptPath, script) {
    return function() {
      var command, commandArgs, execArgs;
      commandArgs = arguments[0], execArgs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      command = "node " + (path.join(scriptPath, script)) + " " + commandArgs;
      execArgs.unshift(command);
      return exec.apply(null, execArgs);
    };
  };

  help = function() {
    var doc, longestNamedTask, maxTaskNameLen, name, task, tasks, _i, _len;
    console.log("" + PROGRAM + " version " + pkg.version + "\n\nusage: " + PROGRAM + " task arg arg arg ...\n\nRun a task from ./jbuild.js or ./jbuild.coffee, passing the\nappropriate args.\n\nThe tasks should be exported from the jsbuild module.");
    if (Tasks == null) {
      process.exit(1);
    }
    console.log("\nAvailable tasks from your jbuild module:\n");
    tasks = _.values(Tasks);
    longestNamedTask = _.max(tasks, function(task) {
      return task.name.length;
    });
    maxTaskNameLen = longestNamedTask.name.length;
    for (_i = 0, _len = tasks.length; _i < _len; _i++) {
      task = tasks[_i];
      name = task.name;
      doc = task.doc;
      console.log("   " + (alignLeft(name, maxTaskNameLen)) + " - " + doc);
    }
    return process.exit(1);
  };

  alignLeft = function(s, len) {
    while (s.length < len) {
      s += " ";
    }
    return s;
  };

  if (require.main === module) {
    main.apply(null, process.argv.slice(2));
  }

}).call(this);
